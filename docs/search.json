[
  {
    "objectID": "posts/lenear/index.html",
    "href": "posts/lenear/index.html",
    "title": "Atividade 3 - Regressão linear",
    "section": "",
    "text": "Nesta tarefa é realizada uma modelagem estatística simples para investigar como os anos de estudo influenciam o salário. Utilizando os dados disponibilizados, os coeficientes da regressão linear são calculados por meio da fórmula matricial. Em seguida, um gráfico é construído com Plotnine, exibindo os pontos observados e a reta estimada, facilitando a visualização da tendência presente nos dados.\n\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom plotnine import ggplot, aes, geom_point, geom_abline, ggsave\nfrom IPython.display import Image, display\n\n# Caminhos padrão onde os arquivos devem estar\nX_path = \"/mnt/data/X.txt\"\ny_path = \"/mnt/data/y.txt\"\n\nprint(\"CWD:\", os.getcwd())\nprint(\"X.txt exists:\", os.path.exists(X_path))\nprint(\"y.txt exists:\", os.path.exists(y_path))\n\n# Leitura dos dados somente se ambos os arquivos existirem no diretório inicial\nif os.path.exists(X_path) and os.path.exists(y_path):\n\n    # Ajusta caminhos para garantir leitura no diretório atual\n    X_path = os.path.join(os.getcwd(), 'X.txt')\n    y_path = os.path.join(os.getcwd(), 'y.txt')\n\n    print('CWD:', os.getcwd())\n    print('X.txt exists:', os.path.exists(X_path))\n    print('y.txt exists:', os.path.exists(y_path))\n\n    # Carregamento dos dados; caso falhe, usa valores constantes como fallback\n    if os.path.exists(X_path) and os.path.exists(y_path):\n        X = np.loadtxt(X_path)\n        y = np.loadtxt(y_path)\n    else:\n        print('Arquivos não encontrados — carregando valores default.')\n        X = np.full(50, 4.6317925681770316)\n        y = np.full_like(X, 12439.153947498304)\n\n    # Garante que os vetores sejam unidimensionais\n    X = np.asarray(X).ravel()\n    y = np.asarray(y).ravel()\n\n    print('shapes:', X.shape, y.shape)\n\n    # Ajuste da regressão: caso X não varie, a inclinação será zero\n    if np.isclose(np.var(X), 0):\n        intercepto = float(np.mean(y))\n        inclinacao = 0.0\n    else:\n        X_mat = np.vstack([np.ones_like(X), X]).T\n        beta = np.linalg.lstsq(X_mat, y, rcond=None)[0]\n        intercepto, inclinacao = float(beta[0]), float(beta[1])\n\n    # Construção do gráfico da regressão usando matplotlib\n    df = pd.DataFrame({'x': X, 'y': y})\n    fig, ax = plt.subplots(figsize=(8, 4.5))\n\n    ax.scatter(df['x'], df['y'], color='tab:blue', label='Dados observados')\n\n    x_line = np.linspace(df['x'].min(), df['x'].max(), 200)\n    ax.plot(x_line, intercepto + inclinacao * x_line, color='red', label='Linha de regressão')\n\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    ax.legend()\n    fig.tight_layout()\n\n    fig.savefig('grafico_regressao.png', dpi=150)\n    display(Image('grafico_regressao.png'))\n\n    print(f'Intercepto: {intercepto:.4f}')\n    print(f'Inclinação: {inclinacao:.4f}')\n\nCWD: /workspaces/ANDRE-S-BLOG/posts/lenear\nX.txt exists: False\ny.txt exists: False\n\n\n\n\n\nGráfico de regressão"
  },
  {
    "objectID": "posts/onibus/index.html",
    "href": "posts/onibus/index.html",
    "title": "Atividade 2 - Monitoramento de Frota de Ônibus",
    "section": "",
    "text": "O objetivo desta atividade é implementar uma ferramenta visual para acompanhar em tempo real o funcionamento de uma linha de ônibus. O sistema busca, via API, tanto as paradas fixas quanto as posições atualizadas dos veículos. Com essas informações, é gerado um mapa interativo que destaca cada tipo de ponto com marcadores de cores diferentes, permitindo identificar facilmente o trajeto oficial e a movimentação atual da frota.\n\n# Versão robusta: utiliza o token SPTRANS_TOKEN caso exista; se não houver, usa dados locais para demonstração.\nimport os\nimport requests\nfrom dotenv import load_dotenv\nfrom IPython.display import HTML, display\nimport folium\nimport math\n\nload_dotenv()\ntoken = os.getenv(\"SPTRANS_TOKEN\")\n\ns = requests.Session()\n\n# Conjunto de dados fictícios utilizado quando o token não estiver disponível ou a API falhar\ndemo_paradas = [\n    {\"cp\": 7014417, \"np\": \"ANGELICA B/C\", \"ed\": \"AV ANGELICA\", \"py\": -23.534564, \"px\": -46.654302},\n    {\"cp\": 60016784, \"np\": \"PARADA PALMEIRAS B/C\", \"ed\": \"R PADRE ANTONIO TOMAS\", \"py\": -23.525799, \"px\": -46.679251},\n    {\"cp\": 60016786, \"np\": \"ANTARTICA B/C\", \"ed\": \"PC SOUSA ARANHA\", \"py\": -23.526523, \"px\": -46.673588},\n    {\"cp\": 12783, \"np\": \"PARADA D\", \"ed\": \"R EXEMPLO\", \"py\": -23.535317, \"px\": -46.653005},\n]\n\ndemo_pos = [\n    {\"p\": \"12783\", \"ta\": \"2024-09-27T01:05:47Z\", \"py\": -23.53531725, \"px\": -46.653005},\n    {\"p\": \"12534\", \"ta\": \"2024-09-27T01:06:10Z\", \"py\": -23.547649, \"px\": -46.6410115},\n]\n\ndef fetch_paradas_pos(codigo_linha=2506):\n    \"\"\"\n    Obtém as paradas e posições dos veículos da linha desejada.\n    - Se o token estiver disponível e a API responder corretamente, usa dados reais.\n    - Caso contrário, retorna os dados de demonstração pré-definidos.\n    \"\"\"\n    if not token:\n        print(\"SPTRANS_TOKEN ausente — carregando dados de demonstração.\")\n        return demo_paradas, demo_pos\n\n    try:\n        # Autenticação junto à API (algumas versões usam GET ou POST; aqui mantemos POST como padrão)\n        auth = s.post(\n            f\"https://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={token}\", timeout=10\n        )\n        print(\"Resposta do login:\", auth.text)\n\n        # Requisição das paradas da linha informada\n        r_par = s.get(\n            f\"https://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha={codigo_linha}\",\n            timeout=10\n        )\n        paradas = r_par.json()\n\n        # Requisição da posição dos veículos\n        r_pos = s.get(\n            f\"https://api.olhovivo.sptrans.com.br/v2.1/Posicao/Linha?codigoLinha={codigo_linha}\",\n            timeout=10\n        )\n        pos_json = r_pos.json()\n        pos_list = pos_json.get(\"vs\") if isinstance(pos_json, dict) else []\n\n        # Se a API retornar lista vazia, usar dados fictícios\n        if not paradas:\n            print(\"Nenhuma parada retornada pela API — usando dados de demonstração.\")\n            return demo_paradas, demo_pos\n\n        return paradas, pos_list\n\n    except Exception as e:\n        print(\"Falha ao acessar a API Olho Vivo:\", e)\n        print(\"Utilizando dados de demonstração.\")\n        return demo_paradas, demo_pos\n\n\n# Carrega paradas e veículos (da API ou demo)\nparadas, pos_list = fetch_paradas_pos(codigo_linha=2506)\nprint(f\"Quantidade carregada: {len(paradas)} paradas, {len(pos_list)} veículos.\")\n\n# Função para calcular o ponto médio das coordenadas — usado como centro do mapa\ndef mean_center(points):\n    lat = [p[\"py\"] for p in points]\n    lon = [p[\"px\"] for p in points]\n    return (sum(lat) / len(lat), sum(lon) / len(lon))\n\n# Caso não existam paradas (situação rara), define um centro padrão\ncenter = mean_center(paradas) if paradas else (-23.534564, -46.654302)\n\n# Criação do mapa com Folium\nm = folium.Map(location=center, zoom_start=14)\n\n# Marca cada parada como um marcador simples\nfor p in paradas:\n    folium.Marker(\n        location=[p[\"py\"], p[\"px\"]],\n        popup=f\"{p.get('np')}\\n{p.get('ed','')}\"\n    ).add_to(m)\n\n# Marca veículos da linha usando círculos vermelhos (se existirem)\nfor v in pos_list:\n    try:\n        folium.CircleMarker(\n            location=[v[\"py\"], v[\"px\"]],\n            radius=6,\n            color=\"red\",\n            fill=True,\n            fill_opacity=0.8,\n            popup=f\"Veículo: {v.get('p')}\\nHorário: {v.get('ta')}\"\n        ).add_to(m)\n    except Exception:\n        pass\n\n# Salva o arquivo HTML do mapa\noutput = \"paradas_linha_2506.html\"\nm.save(output)\nprint(f\"Arquivo gerado: {output}\")\n\n# Exibe o mapa diretamente no Quarto\ndisplay(HTML(m._repr_html_()))\n\nSPTRANS_TOKEN ausente — carregando dados de demonstração.\nQuantidade carregada: 4 paradas, 2 veículos.\nArquivo gerado: paradas_linha_2506.html\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ANDRE-S-BLOG",
    "section": "",
    "text": "Atividade 2 - Monitoramento de Frota de Ônibus\n\n\n\nAPI\n\nPYTHON\n\nCODE\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAndré Bellin\n\n\n\n\n\n\n\n\n\n\n\n\nAtividae 1 - Cotação Dolar\n\n\n\nJSON\n\nPYTHON\n\nCODE\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAndré Bellin\n\n\n\n\n\n\n\n\n\n\n\n\nAtividade 3 - Regressão linear\n\n\n\nAPI\n\nPYTHON\n\nCODE\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAndré Bellin\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Atividae 1 - Cotação Dolar",
    "section": "",
    "text": "Nesta atividade será desenvolvida uma aplicação capaz de consultar e analisar a variação diária do dólar dentro de um mês específico. A partir de um código no formato ‘MMYYYY’, o programa identifica o intervalo completo do mês, acessa a API do Banco Central e recupera as cotações correspondentes. Também é realizado o tratamento de dias sem registro, ajustando valores com base na última cotação disponível. Ao final, os dados são apresentados em um gráfico interativo de linha construído com Plotly.\n\nimport pandas as pd\nimport requests\nimport calendar\nfrom datetime import datetime\nimport plotly.express as px\n\ndef cotacao_dolar_periodo(mmyyyy: str):\n    \"\"\"\n    Recebe uma string no formato 'MMYYYY' e retorna\n    um gráfico de linha com as cotações diárias do dólar PTAX.\n    \"\"\"\n\n    # Converte a string recebida para o primeiro dia do mês\n    first_date = datetime.strptime(mmyyyy, \"%m%Y\")\n\n    # Descobre automaticamente o último dia do mês informado\n    last_date = first_date.replace(\n        day=calendar.monthrange(first_date.year, first_date.month)[1]\n    )\n\n    # Formata datas no padrão aceito pela API PTAX (mm-dd-yyyy)\n    data_ini = first_date.strftime(\"%m-%d-%Y\")\n    data_fim = last_date.strftime(\"%m-%d-%Y\")\n\n    # Monta a URL do serviço PTAX para consulta de cotações no período\n    url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        \"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n        f\"?@dataInicial='{data_ini}'&@dataFinalCotacao='{data_fim}'\"\n        \"&$top=100&$format=json\"\n    )\n\n    # Faz a requisição à API e extrai a lista de registros do JSON\n    response = requests.get(url)\n    dados = response.json()[\"value\"]\n\n    # Constrói DataFrame e extrai somente data, compra e venda\n    df = pd.DataFrame(dados)\n    df[\"data\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n    df = df[[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"]]\n\n    # Remove múltiplas cotações do mesmo dia, fazendo a média\n    df = df.groupby(\"data\").mean().reset_index()\n    df = df.sort_values(\"data\")\n\n    # Recria o índice com todas as datas do mês e preenche lacunas com forward-fill\n    idx = pd.date_range(start=first_date, end=last_date)\n    df = df.set_index(\"data\").reindex(idx)\n    df = df.fillna(method=\"ffill\")\n    df.index.name = \"data\"\n    df = df.reset_index()\n\n    # Gera o gráfico de linha com Plotly\n    fig = px.line(\n        df,\n        x=\"data\",\n        y=\"cotacaoVenda\",\n        title=f\"Cotação do Dólar {mmyyyy[:2]}/{mmyyyy[2:]}\",\n        labels={\"cotacaoVenda\": \"Cotação (Venda)\", \"data\": \"Data\"}\n    )\n\n    fig.update_layout(yaxis_tickformat=\".2f\")\n    return fig\n\n# Executando para sua data 07/2016\ncotacao_dolar_periodo(\"072016\")\n\n/tmp/ipykernel_74806/537669863.py:49: FutureWarning:\n\nDataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead."
  }
]