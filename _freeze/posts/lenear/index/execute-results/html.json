{
  "hash": "5560e0ef9316efe8b43af0e1144d9fbb",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Atividade 3 - Regressão linear\"\nauthor: André Bellin\ndate: \"2025-11-23\"\ncategories: [API, PYTHON, CODE]\nimage: \"grafico_regressao.png\"\n---\n\nNesta tarefa é realizada uma modelagem estatística simples para investigar como os anos de estudo influenciam o salário. Utilizando os dados disponibilizados, os coeficientes da regressão linear são calculados por meio da fórmula matricial. Em seguida, um gráfico é construído com Plotnine, exibindo os pontos observados e a reta estimada, facilitando a visualização da tendência presente nos dados.\n\n::: {#ad84047e .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom plotnine import ggplot, aes, geom_point, geom_abline, ggsave\nfrom IPython.display import Image, display\n\n# Caminhos padrão onde os arquivos devem estar\nX_path = \"/mnt/data/X.txt\"\ny_path = \"/mnt/data/y.txt\"\n\nprint(\"CWD:\", os.getcwd())\nprint(\"X.txt exists:\", os.path.exists(X_path))\nprint(\"y.txt exists:\", os.path.exists(y_path))\n\n# Leitura dos dados somente se ambos os arquivos existirem no diretório inicial\nif os.path.exists(X_path) and os.path.exists(y_path):\n\n    # Ajusta caminhos para garantir leitura no diretório atual\n    X_path = os.path.join(os.getcwd(), 'X.txt')\n    y_path = os.path.join(os.getcwd(), 'y.txt')\n\n    print('CWD:', os.getcwd())\n    print('X.txt exists:', os.path.exists(X_path))\n    print('y.txt exists:', os.path.exists(y_path))\n\n    # Carregamento dos dados; caso falhe, usa valores constantes como fallback\n    if os.path.exists(X_path) and os.path.exists(y_path):\n        X = np.loadtxt(X_path)\n        y = np.loadtxt(y_path)\n    else:\n        print('Arquivos não encontrados — carregando valores default.')\n        X = np.full(50, 4.6317925681770316)\n        y = np.full_like(X, 12439.153947498304)\n\n    # Garante que os vetores sejam unidimensionais\n    X = np.asarray(X).ravel()\n    y = np.asarray(y).ravel()\n\n    print('shapes:', X.shape, y.shape)\n\n    # Ajuste da regressão: caso X não varie, a inclinação será zero\n    if np.isclose(np.var(X), 0):\n        intercepto = float(np.mean(y))\n        inclinacao = 0.0\n    else:\n        X_mat = np.vstack([np.ones_like(X), X]).T\n        beta = np.linalg.lstsq(X_mat, y, rcond=None)[0]\n        intercepto, inclinacao = float(beta[0]), float(beta[1])\n\n    # Construção do gráfico da regressão usando matplotlib\n    df = pd.DataFrame({'x': X, 'y': y})\n    fig, ax = plt.subplots(figsize=(8, 4.5))\n\n    ax.scatter(df['x'], df['y'], color='tab:blue', label='Dados observados')\n\n    x_line = np.linspace(df['x'].min(), df['x'].max(), 200)\n    ax.plot(x_line, intercepto + inclinacao * x_line, color='red', label='Linha de regressão')\n\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    ax.legend()\n    fig.tight_layout()\n\n    fig.savefig('grafico_regressao.png', dpi=150)\n    display(Image('grafico_regressao.png'))\n\n    print(f'Intercepto: {intercepto:.4f}')\n    print(f'Inclinação: {inclinacao:.4f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCWD: /workspaces/ANDRE-S-BLOG/posts/lenear\nX.txt exists: False\ny.txt exists: False\n```\n:::\n:::\n\n\n![Gráfico de regressão](grafico_regressao.png)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}